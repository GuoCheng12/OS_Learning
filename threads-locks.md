## threads-locks

· threads-locks

·    控制中断为最早提供互斥的方法之一，优点是很简单，但缺点很多（不适合在多处理器上运作、不安全（要求我们允许调用线程执行特权操作）、效率比较慢）

·    单独的Loads/Stores不能满足互斥这样的情况，因为考虑到中断问题（及时和不及时）所以很容易两个线程都能够进入临界区

·    基于上面Loads/Stores、系统中断的实效性，我们“软件不够、硬件来凑”——test and set / atomic xchg

·    有了硬件的帮助，我们有了自旋锁(spin lock)，很好解决了我们“互斥”的问题

·    spin lock 有几个致命的缺点: 1.在争用的情况下，一个线程的锁有可能永远都在旋转，这样可能会导致饥饿

·    新的硬件操作——CompareAndSwap ( 也是原子性的）判断PTR和预期是否相同，如果相同则更新PTR（交换）

·    CompareAndSwap的功能性比xchg要强（当我们讲到“无锁同步”的时候，但是我们当前使用的简单自旋锁（用CAW）的和上面的自旋锁其实是相同的

·    硬件上的支持可以让我们很好的完成很多spinning lock，但是缺点可见（饥饿问题、CPU开销太大）

·    提出yield方法，当一个线程thread1想要调用一个已经被占用的锁时，会从running 切换成 yield 然后将CPU让出来给别的线程使用。但是这也有缺点：假设有100个线程，其中只有一个线程能得到key之后占据线程，所以另外的99个线程都必须在那一个线程再次启动前执行一次run->yield这个过程，非常的费时间和费资源。再者：还有饥饿问题没有解决。

·    spining lock同样还有很多很差劲的缺点，其中危险的一个就是“优先级反转”（PRIORITY INVERSION），这个问题甚至会直接导致线程间的优先级会发生变化。

·    解决上面的问题，想出了新的一个解决办法——Queue / Sleeping。将得不到锁的线程，放入到一个等待队列，当有资源时再将其中的某一个线程释放出来，获得锁...

·    但是系统调用的代价是很大的，如果临界区比较长，这也是一个很大的开销

·    Solaris上有一个park( )和unpark( ) 这样的语句——提供自旋锁+互斥锁

·    在Linux里，提供了一个futex这样的锁，包含了 spinning lock 和 sleeping lock

·     

·    总结：构建真正的锁 = hardware support +OS support